import { CreateAccountError, createClient, CreateTransferError, id } from 'tigerbeetle-node';
import { Stores } from './stores.js';

export class TigerBeetleStores implements Stores {
    client;
    accountCache: {
      [ledgerId: number]: object[]
    };
    constructor() {
    }
    async ensureBalance(thisParty: number, otherParty: number): Promise<{ ledgerId: number, thisPartyId: bigint, otherPartyId: bigint}> {
      // `thisParty` is 1,2,3,...
      // `otherParty` is 0,1,2,... and thisParty!=otherparty.
      // The accountId's are generated by adding 1 million times the ledgerId to them (so we can never have more than 999,999 accounts)
      // The ledgerId is the same as `thisParty`.
      // So for example a transfer from account 37 to account 54235 on the ledger of account 37 would have:
      // ledgerId: 37
      // thisPartyId: 37,000,037
      // otherPartyId: 37,054,235
      const ledgerId = thisParty;
      const thisPartyId = BigInt(1000 * 1000 * ledgerId) + BigInt(thisParty);
      const otherPartyId = BigInt(1000 * 1000 * ledgerId) + BigInt(otherParty);
      // console.log('creating accounts', ledgerId, thisPartyId, otherPartyId);
      const mainAccount = {
        id: thisPartyId,
        debits_pending: 0n,
        debits_posted: 0n,
        credits_pending: 0n,
        credits_posted: 0n,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        reserved: 0,
        ledger: ledgerId,
        code: 1,
        flags: 0,
        timestamp: 0n,
      };
      const otherAccount = {
        id: otherPartyId,
        debits_pending: 0n,
        debits_posted: 0n,
        credits_pending: 0n,
        credits_posted: 0n,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        reserved: 0,
        ledger: ledgerId,
        code: 1,
        flags: 0,
        timestamp: 0n,
      };
      // NB: there is no way to 'upsert' an account, so we just create them and catch the error if it already exists.
      const accountErrors: { index: number, result: number}[] = await this.client.createAccounts([mainAccount, otherAccount]);
      accountErrors.forEach(({ index, result }: { index: number, result: number})  => {
        if (result !== CreateAccountError["exists"]) {
          throw new Error(`error creating TigerBeetle account ${index} ${CreateAccountError[result]}`);
        }
      });
      // console.log('account created', accountErrors, );
      return {
        ledgerId,
        thisPartyId,
        otherPartyId
      }
    }
    async connect(): Promise<void> {
      // const myPort = (3000 + parseInt(process.env.WORKER)%3).toString();
      // console.log(`client ${process.env.WORKER} connects to replica ${myPort}`);
      this.client = createClient({
        cluster_id: 0n,
        replica_addresses: ["3000"],
      });
      // noop
    } 
    async disconnect(): Promise<void> {
      // noop
  }
    async storeTransaction({ thisParty, otherParty, amount }: { thisParty: number, otherParty: number, amount: number }): Promise<number> {
      // console.log('storeTransaction', thisParty, otherParty, amount);
      const absAmount = Math.abs(amount);
      const firstChunk = Math.round(absAmount);
      const afterFirst = 1000 * 1000 * (absAmount - firstChunk);
      const secondChunk = Math.round(afterFirst);
      const afterSecond = 1000 * 1000 * (afterFirst - secondChunk);
      const lastChunk = Math.round(afterSecond);

      const scaledAmount =
        BigInt(firstChunk) * BigInt(1000 * 1000) * BigInt(1000 * 1000) +
        BigInt(secondChunk) * BigInt(1000 * 1000) +
        BigInt(lastChunk);

      const { ledgerId, thisPartyId, otherPartyId } = await this.ensureBalance(thisParty, otherParty);
      // this.balances[thisParty][otherParty] += amount;
      let debit_account_id, credit_account_id;
      if (amount >= 0) {
        debit_account_id = thisPartyId;
        credit_account_id = otherPartyId;
      } else {
        debit_account_id = otherPartyId;
        credit_account_id = thisPartyId;
      }
      const transfers = [{
        id: id(),
        debit_account_id,
        credit_account_id,
        amount: scaledAmount,
        pending_id: 0n,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        timeout: 0,
        ledger: ledgerId,
        code: 720,
        flags: 0,
        timestamp: 0n,
      }];
      // console.log('creating transfer', debit_account_id, credit_account_id, ledgerId);
      const transferErrors = await this.client.createTransfers(transfers);
      if (transferErrors.length > 0) {
        console.log(thisParty, otherParty, amount, thisPartyId, debit_account_id, credit_account_id, scaledAmount, transferErrors.map(error => {
          return {
            index: error.index,
            result: CreateTransferError[error.result]
          }
        }));
      }
      return amount;
    }
    async logTransfers(): Promise<void> {
      const query_transfers = await this.client.queryTransfers({
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        code: 0,
        ledger: 0,
        timestamp_min: 0n,
        timestamp_max: 0n,
        limit: 10000000,
        flags: 0,
      });
      console.log(query_transfers);
    }
    async logBalances(): Promise<void> {
      const query_accounts = await this.client.queryAccounts({
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        code: 0,
        ledger: 0,
        timestamp_min: 0n,
        timestamp_max: 0n,
        limit: 100000,
        flags: 0,
      });
      query_accounts.filter(({
        id,
        ledger,
     }) => (BigInt(ledger) * BigInt(1000001) === id)).forEach(({
        debits_posted,
        credits_posted,
        ledger,
      }) => console.log(`${ledger}:${(BigInt(debits_posted) - BigInt(credits_posted))/(BigInt(1000000)*BigInt(1000000))}`));
    }
    async updateAccountCache(): Promise<void> {
      console.log('querying all accounts on all ledgers...');
      const allAccounts = await this.client.queryAccounts({
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        code: 0,
        ledger: 0,
        timestamp_min: 0n,
        timestamp_max: 0n,
        limit: 1000000,
        flags: 0,
      });
      console.log('accounts found', allAccounts.length);
      this.accountCache = {};
      let numLedgers = 0;
      let highestLedger = 0;
      allAccounts.forEach(x => {
        if (typeof this.accountCache[x.ledger] === 'undefined') {
          this.accountCache[x.ledger] = [];
          numLedgers++;
          if (x.ledger > highestLedger) {
            highestLedger = x.ledger;
          }
        }
        // console.log('account found on ledger', x.ledger);
        this.accountCache[x.ledger].push(x);
      });
      console.log(`${allAccounts.length} accounts cached across ${numLedgers} ledgers ranging up to ${highestLedger}`);
    }
    async logLedgerSizes(): Promise<void> {
      await this.updateAccountCache();
      for (let i = 1; i < 100000; i++) {
        console.log(i,  this.accountCache[i]?.length);
      }
    }
    async logBestPairs(): Promise<void> {
      await this.updateAccountCache();
      let numBestPairs = 0;
      Object.keys(this.accountCache).forEach(i => {
        const ledgerBalances = this.accountCache[i];
        const balances = {};
        ledgerBalances
          .filter(({ id }) => (Number(id - BigInt(i)*BigInt(1000000)) !== 0)) // filter out bank
          .filter(({ id }) => (Number(id - BigInt(i)*BigInt(1000000)) !== parseInt(i))) // filter out self
          .map(({ id, debits_posted, credits_posted }) => {
            balances[Number(id - BigInt(i)*BigInt(1000000))] = Number((BigInt(debits_posted) - BigInt(credits_posted))/(BigInt(1000000)*BigInt(1000000)));
          });
        let min = Infinity;
        let minParty;
        let max = -Infinity;
        let maxParty;
        Object.keys(balances).forEach(otherParty => {
          if (balances[otherParty] < min) {
            // console.log('New min', i, min, otherParty, balances[otherParty], max);
            min = balances[otherParty];
            minParty = otherParty;
          }
          if (balances[otherParty] > max) {
            // console.log('New max', i, min, otherParty, balances[otherParty], max);
            max = balances[otherParty];
            maxParty = otherParty;
          }
          // console.log('No winner', i, min, otherParty, balances[otherParty], max);
        });
        if ((min < 0.0) &&(max > 0.0)) {
          numBestPairs++;
          console.log(`Node ${i} has best pair with node ${minParty} (${min}) and ${maxParty} (${max})`);
        }
      });
      console.log(`logBestPairs found ${numBestPairs} out of ${Object.keys(this.accountCache).length} ledgers that have both incoming and outgoing balances`);
    }
    async logPaths(): Promise<string> {
      return new Promise((resolve) => {
        // console.log('query start', process.env.WORKER);
        //eslint-disable-next-line @typescript-eslint/no-explicit-any
        // const startTime: any = new Date();
        const latencyTimer = setTimeout(() => {
          //eslint-disable-next-line @typescript-eslint/no-explicit-any
          // const now: any = new Date();
          // console.log(`query running`, (now - startTime), process.env.WORKER);
          resolve('FAIL');
        }, 10000);
        this.client.queryAccounts({
          user_data_128: 0n,
          user_data_64: 0n,
          user_data_32: 0,
          code: 0,
          ledger: 0,
          timestamp_min: 0n,
          timestamp_max: 0n,
          limit: 1000000,
          flags: 0,
        }).then(() => {
          clearTimeout(latencyTimer);
          //eslint-disable-next-line @typescript-eslint/no-explicit-any
          // const endTime: any = new Date();
          // console.log('query end', (endTime - startTime), process.env.WORKER);
          resolve('OK');
        });
      });
    }
    async logLedgers(): Promise<string> {
      // await this.logTransfers();
      // await this.logBalances();
      // await this.logBestPairs();
      // await this.logLedgerSizes();
      return this.logPaths();
    }
    async getBalances(): Promise<{
      [nodeNo: number]: {
        [neighbour: number]: number
      }
    }> {
      return {};
    }  
  }