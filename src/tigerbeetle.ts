import { CreateAccountError, createClient, CreateTransferError, id } from 'tigerbeetle-node';
import { Stores } from './stores.js';

const PORTS = ["3000"];
const TRANSFER_BATCH_SIZE = 100;

export class TigerBeetleStores implements Stores {
  accountsCreated = {};
  transferBatch = [];
  client;
  accountCache: {
    [ledgerId: number]: object[]
  };
  constructor() {
  }
  async ensureAccountsExist(thisParty: number, otherParty: number): Promise<{ ledgerId: number, thisPartyId: bigint, otherPartyId: bigint}> {
    // `thisParty` is 1,2,3,...
    // `otherParty` is 0,1,2,... and thisParty!=otherparty.
    // The accountId's are generated by adding 1 million times the ledgerId to them (so we can never have more than 999,999 accounts)
    // The ledgerId is the same as `thisParty`.
    // So for example a transfer from account 37 to account 54235 on the ledger of account 37 would have:
    // ledgerId: 37
    // thisPartyId: 37,000,037
    // otherPartyId: 37,054,235
    const ledgerId = thisParty;
    const thisPartyId = BigInt(1000 * 1000 * ledgerId) + BigInt(thisParty);
    const otherPartyId = BigInt(1000 * 1000 * ledgerId) + BigInt(otherParty);
    // console.log('creating accounts', ledgerId, thisPartyId, otherPartyId);
    const mainAccount = {
      id: thisPartyId,
      debits_pending: 0n,
      debits_posted: 0n,
      credits_pending: 0n,
      credits_posted: 0n,
      user_data_128: 0n,
      user_data_64: 0n,
      user_data_32: 0,
      reserved: 0,
      ledger: ledgerId,
      code: 1,
      flags: 0,
      timestamp: 0n,
    };
    const otherAccount = {
      id: otherPartyId,
      debits_pending: 0n,
      debits_posted: 0n,
      credits_pending: 0n,
      credits_posted: 0n,
      user_data_128: 0n,
      user_data_64: 0n,
      user_data_32: 0,
      reserved: 0,
      ledger: ledgerId,
      code: 1,
      flags: 0,
      timestamp: 0n,
    };
    const accountsToCreate = [];
    if (typeof this.accountsCreated[Number(thisPartyId)] === 'undefined') {
      this.accountsCreated[Number(thisPartyId)] = true;
      accountsToCreate.push(mainAccount);
    }
    if (typeof this.accountsCreated[Number(otherPartyId)] === 'undefined') {
      this.accountsCreated[Number(otherPartyId)] = true;
      accountsToCreate.push(otherAccount);
    }
    if (accountsToCreate.length > 0) {
      // console.log('creating accounts', accountsToCreate);
      // NB: there is no way to 'upsert' an account, so we just create them and catch the error if it already exists.
      const accountErrors: { index: number, result: number}[] = await this.client.createAccounts(accountsToCreate);
      accountErrors.forEach(({ index, result }: { index: number, result: number})  => {
        if (result !== CreateAccountError["exists"]) {
          throw new Error(`error creating TigerBeetle account ${index} ${CreateAccountError[result]}`);
        }
      });
      // console.log('account created', accountErrors);
    }
    return {
      ledgerId,
      thisPartyId,
      otherPartyId
    }
  }
  async connect(): Promise<void> {
    // const myPort = (3000 + parseInt(process.env.WORKER)%3).toString();
    // console.log(`client ${process.env.WORKER} connects to replica ${myPort}`);
    this.client = createClient({
      cluster_id: 0n,
      replica_addresses: PORTS,
    });
    // noop
  } 
  async disconnect(): Promise<void> {
    this.flushTransfers();
    delete this.client;
  }
  async storeTransaction({ txid, thisParty, otherParty, amount }: { txid: number, thisParty: number, otherParty: number, amount: number }): Promise<void> {
      // console.log('storeTransaction', thisParty, otherParty, amount);
      const absAmount = Math.abs(amount);
      const firstChunk = Math.round(absAmount);
      const afterFirst = 1000 * 1000 * (absAmount - firstChunk);
      const secondChunk = Math.round(afterFirst);
      const afterSecond = 1000 * 1000 * (afterFirst - secondChunk);
      const lastChunk = Math.round(afterSecond);

      const scaledAmount =
        BigInt(firstChunk) * BigInt(1000 * 1000) * BigInt(1000 * 1000) +
        BigInt(secondChunk) * BigInt(1000 * 1000) +
        BigInt(lastChunk);

      // console.log('ensuring accounts exist start');
      const { ledgerId, thisPartyId, otherPartyId } = await this.ensureAccountsExist(thisParty, otherParty);
      // console.log('ensuring accounts exist end');
      // this.balances[thisParty][otherParty] += amount;
      let debit_account_id, credit_account_id;
      if (amount >= 0) {
        debit_account_id = thisPartyId;
        credit_account_id = otherPartyId;
      } else {
        debit_account_id = otherPartyId;
        credit_account_id = thisPartyId;
      }
      this.transferBatch.push({
        id: id(),
        debit_account_id,
        credit_account_id,
        amount: scaledAmount,
        pending_id: 0n,
        user_data_128: BigInt(txid),
        user_data_64: 0n,
        user_data_32: 0,
        timeout: 0,
        ledger: ledgerId,
        code: 720,
        flags: 0,
        timestamp: 0n,
      });
      if (this.transferBatch.length === TRANSFER_BATCH_SIZE) {
        // console.log('flush start');
        await this.flushTransfers();
        // console.log('flush end');
      }
    }
    async flushTransfers(): Promise<void> {
      const thisBatch = [ ...this.transferBatch];
      this.transferBatch = [];
      console.log('creating transfers', thisBatch);
      if (thisBatch.length === 0) {
        return;
      }
      await this.client.createTransfers(thisBatch).then((transferErrors) => {
        if (transferErrors.length > 0) {
          transferErrors.map(error => {
            console.log(thisBatch[error.index], CreateTransferError[error.result]);
            return {
              index: error.index,
              result: CreateTransferError[error.result]
            }
          });
          process.exit(1);
        }
      });
    }
    async logTransfers(): Promise<void> {
      const query_transfers = await this.client.queryTransfers({
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        code: 0,
        ledger: 0,
        timestamp_min: 0n,
        timestamp_max: 0n,
        limit: 10000000,
        flags: 0,
      });
      console.log(query_transfers);
    }
    async logBalances(): Promise<void> {
      const query_accounts = await this.client.queryAccounts({
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        code: 0,
        ledger: 0,
        timestamp_min: 0n,
        timestamp_max: 0n,
        limit: 100000,
        flags: 0,
      });
      query_accounts.filter(({
        id,
        ledger,
     }) => (BigInt(ledger) * BigInt(1000001) === id)).forEach(({
        debits_posted,
        credits_posted,
        ledger,
      }) => console.log(`${ledger}:${(BigInt(debits_posted) - BigInt(credits_posted))/(BigInt(1000000)*BigInt(1000000))}`));
    }
    async updateAccountCache(): Promise<void> {
      console.log('querying all accounts on all ledgers...');
      const allAccounts = await this.client.queryAccounts({
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        code: 0,
        ledger: 0,
        timestamp_min: 0n,
        timestamp_max: 0n,
        limit: 1000000,
        flags: 0,
      });
      console.log('accounts found', allAccounts.length);
      this.accountCache = {};
      let numLedgers = 0;
      let highestLedger = 0;
      allAccounts.forEach(x => {
        if (typeof this.accountCache[x.ledger] === 'undefined') {
          this.accountCache[x.ledger] = [];
          numLedgers++;
          if (x.ledger > highestLedger) {
            highestLedger = x.ledger;
          }
        }
        // console.log('account found on ledger', x.ledger);
        this.accountCache[x.ledger].push(x);
      });
      console.log(`${allAccounts.length} accounts cached across ${numLedgers} ledgers ranging up to ${highestLedger}`);
    }
    async logLedgerSizes(): Promise<void> {
      await this.updateAccountCache();
      for (let i = 1; i < 100000; i++) {
        console.log(i,  this.accountCache[i]?.length);
      }
    }
    async logBestPairs(): Promise<void> {
      await this.updateAccountCache();
      let numBestPairs = 0;
      Object.keys(this.accountCache).forEach(i => {
        const ledgerBalances = this.accountCache[i];
        const balances = {};
        ledgerBalances
          .filter(({ id }) => (Number(id - BigInt(i)*BigInt(1000000)) !== 0)) // filter out bank
          .filter(({ id }) => (Number(id - BigInt(i)*BigInt(1000000)) !== parseInt(i))) // filter out self
          .map(({ id, debits_posted, credits_posted }) => {
            balances[Number(id - BigInt(i)*BigInt(1000000))] = Number((BigInt(debits_posted) - BigInt(credits_posted))/(BigInt(1000000)*BigInt(1000000)));
          });
        let min = Infinity;
        let minParty;
        let max = -Infinity;
        let maxParty;
        Object.keys(balances).forEach(otherParty => {
          if (balances[otherParty] < min) {
            // console.log('New min', i, min, otherParty, balances[otherParty], max);
            min = balances[otherParty];
            minParty = otherParty;
          }
          if (balances[otherParty] > max) {
            // console.log('New max', i, min, otherParty, balances[otherParty], max);
            max = balances[otherParty];
            maxParty = otherParty;
          }
          // console.log('No winner', i, min, otherParty, balances[otherParty], max);
        });
        if ((min < 0.0) &&(max > 0.0)) {
          numBestPairs++;
          console.log(`Node ${i} has best pair with node ${minParty} (${min}) and ${maxParty} (${max})`);
        }
      });
      console.log(`logBestPairs found ${numBestPairs} out of ${Object.keys(this.accountCache).length} ledgers that have both incoming and outgoing balances`);
    }
    async logPaths(): Promise<string> {
      return new Promise((resolve) => {
        // console.log('query start', process.env.WORKER);
        //eslint-disable-next-line @typescript-eslint/no-explicit-any
        // const startTime: any = new Date();
        const latencyTimer = setTimeout(() => {
          //eslint-disable-next-line @typescript-eslint/no-explicit-any
          // const now: any = new Date();
          // console.log(`query running`, (now - startTime), process.env.WORKER);
          resolve('FAIL');
        }, 10000);
        this.client.queryAccounts({
          user_data_128: 0n,
          user_data_64: 0n,
          user_data_32: 0,
          code: 0,
          ledger: 0,
          timestamp_min: 0n,
          timestamp_max: 0n,
          limit: 1000000,
          flags: 0,
        }).then(() => {
          clearTimeout(latencyTimer);
          //eslint-disable-next-line @typescript-eslint/no-explicit-any
          // const endTime: any = new Date();
          // console.log('query end', (endTime - startTime), process.env.WORKER);
          resolve('OK');
        });
      });
    }
    async logLedgers(): Promise<string> {
      // await this.logTransfers();
      // await this.logBalances();
      // await this.logBestPairs();
      // await this.logLedgerSizes();
      return this.logPaths();
    }
    async getBalances(): Promise<{
      [nodeNo: number]: {
        [neighbour: number]: number
      }
    }> {
      const query_accounts = await this.client.queryAccounts({
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        code: 0,
        ledger: 0,
        timestamp_min: 0n,
        timestamp_max: 0n,
        limit: 100000,
        flags: 0,
      });
      query_accounts.filter(({
        id,
        ledger,
     }) => (BigInt(ledger) * BigInt(1000001) === id)).forEach(({
        debits_posted,
        credits_posted,
        ledger,
      }) => console.log(`${ledger}:${(BigInt(debits_posted) - BigInt(credits_posted))/(BigInt(1000000)*BigInt(1000000))}`));
      return {};
    }
    async getTransactionIds(): Promise<string> {
      const query_transfers = await this.client.queryTransfers({
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        code: 0,
        ledger: 0,
        timestamp_min: 0n,
        timestamp_max: 0n,
        limit: 100000,
        flags: 0,
      });
      const found = {};
      for (let i = 0; i < query_transfers.length; i++) {
        const txid = Number(query_transfers[i].user_data_128);
        if (typeof found[txid] === 'undefined') {
          found[txid] = 0;
        }
        found[txid]++;
      }
      for (let i = 0; i < 1081; i++) {
        console.log(i, found[i]);
      }
      return found[0].toString();
    }
  }